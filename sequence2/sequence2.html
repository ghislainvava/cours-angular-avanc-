<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>S√©quence 2 - Programmation R√©active avec RxJS</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
            height: 100vh;
        }

        .presentation-container {
            width: 100%;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .slide-counter {
            text-align: center;
            color: white;
            font-size: 1.2em;
            padding: 15px;
            font-weight: bold;
        }

        .slide {
            display: none;
            width: 90%;
            max-width: 1200px;
            margin: auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            padding: 60px;
            animation: slideIn 0.5s ease-out;
            overflow-y: auto;
            max-height: 80vh;
        }

        .slide.active {
            display: block;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        h1 {
            color: #667eea;
            font-size: 2.8em;
            margin-bottom: 30px;
            border-bottom: 4px solid #667eea;
            padding-bottom: 15px;
        }

        h2 {
            color: #764ba2;
            font-size: 2em;
            margin: 25px 0 15px 0;
        }

        h3 {
            color: #555;
            font-size: 1.5em;
            margin: 20px 0 10px 0;
        }

        h4 {
            color: #667eea;
            font-size: 1.3em;
            margin: 15px 0 10px 0;
        }

        p, li {
            font-size: 1.2em;
            line-height: 1.8;
            color: #333;
            margin-bottom: 15px;
        }

        ul, ol {
            margin-left: 30px;
            margin-bottom: 20px;
        }

        li {
            margin-bottom: 10px;
        }

        .highlight {
            background: #fff3cd;
            padding: 20px;
            border-left: 5px solid #ffc107;
            margin: 20px 0;
            border-radius: 5px;
        }

        .info-box {
            background: #d1ecf1;
            border-left: 5px solid #17a2b8;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .success-box {
            background: #d4edda;
            border-left: 5px solid #28a745;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .warning-box {
            background: #f8d7da;
            border-left: 5px solid #dc3545;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
        }

        code {
            background: #f4f4f4;
            padding: 3px 8px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            color: #c7254e;
            font-size: 0.95em;
        }

        pre {
            background: #2d2d2d;
            color: #f8f8f2;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
            line-height: 1.5;
        }

        pre code {
            background: transparent;
            color: #f8f8f2;
            padding: 0;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            padding: 20px;
        }

        .controls button {
            background: white;
            color: #667eea;
            border: 2px solid white;
            padding: 15px 40px;
            font-size: 1.1em;
            border-radius: 30px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .controls button:hover:not(:disabled) {
            background: #667eea;
            color: white;
            transform: scale(1.05);
        }

        .controls button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .date-badge {
            display: inline-block;
            background: #764ba2;
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 0.9em;
            margin-bottom: 20px;
        }

        .emoji {
            font-size: 1.3em;
            margin-right: 5px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }

        th, td {
            padding: 15px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }

        th {
            background: #667eea;
            color: white;
            font-weight: bold;
        }

        tr:hover {
            background: #f8f9fa;
        }

        .comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }

        .comparison-before {
            background: #f8d7da;
            border-left: 4px solid #dc3545;
        }

        .comparison-after {
            background: #d4edda;
            border-left: 4px solid #28a745;
        }

        strong {
            color: #667eea;
        }

        .step-number {
            display: inline-block;
            width: 35px;
            height: 35px;
            background: #667eea;
            color: white;
            border-radius: 50%;
            text-align: center;
            line-height: 35px;
            font-weight: bold;
            margin-right: 10px;
        }

        .flow-diagram {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            text-align: center;
        }

        .flow-step {
            display: inline-block;
            background: #667eea;
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            margin: 5px;
            font-weight: bold;
        }
          .container {
        padding: 3rem;
        border-radius: 1rem;
        box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
         .back-button {
                display: inline-flex;
                align-items: center;
                gap: 10px;
                background: white;
                color: #667eea;
                padding: 12px 25px;
                border-radius: 50px;
                text-decoration: none;
                font-weight: bold;
                transition: all 0.3s ease;
                box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            }
        .slide-counter {
            position: fixed;
            top: 30px;
            right: 30px;
            background: white;
            padding: 15px 25px;
            border-radius: 50px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            font-weight: bold;
            color: #667eea;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div class="presentation-container">

          <div class="container">
            <a href="../index.html" class="back-button">‚Üê Retour au dashboard</a>
            <div class="slide-counter">
                <span id="current-slide">1</span> / <span id="total-slides">30</span>
            </div>

        </div>
       

        <!-- Slide 1 -->
        <div class="slide active">
            <h1>üéØ Objectifs de la s√©ance</h1>
            <div class="date-badge">üìÖ Date: 28/11/2025</div>
            
            <div class="success-box">
                <h3>√Ä la fin de cette s√©ance, vous serez capables de :</h3>
                <ul>
                    <li><strong>Comprendre</strong> la programmation asynchrone et r√©active dans une application Angular</li>
                    <li><strong>Mettre en ≈ìuvre</strong> un service de donn√©es capable d'√©mettre et d'actualiser des flux</li>
                    <li><strong>Afficher et actualiser</strong> ces donn√©es dans la vue √† l'aide d'un m√©canisme r√©actif</li>
                </ul>
            </div>

            <div class="highlight">
                <h3>üí° Projet fil rouge</h3>
                <p style="text-align: center; font-size: 1.3em;">
                    Nous allons rendre <strong>TaskBoard Pro</strong> r√©actif !
                </p>
            </div>
        </div>

        <!-- Slide 2 -->
        <div class="slide">
            <h1>üîÑ D'une application statique √† r√©active</h1>
            
            <div class="warning-box">
                <h3>‚ùå Situation actuelle</h3>
                <p>Jusqu'ici, TaskBoard Pro affiche des pages et des composants.</p>
                <ul>
                    <li>Les donn√©es sont <strong>fixes</strong></li>
                    <li>Le contenu ne change pas sans rechargement</li>
                    <li>L'application n'est pas "vivante"</li>
                </ul>
            </div>

            <div class="success-box">
                <h3>‚úÖ Objectif</h3>
                <p>Rendre l'application <strong>vivante</strong> ‚Äî qu'elle s'adapte aux donn√©es qui √©voluent.</p>
            </div>

            <div class="highlight">
                <h3>üí° Ce que nous allons apprendre</h3>
                <p style="font-size: 1.3em; text-align: center;">
                    "Faire r√©agir Angular aux changements de donn√©es,<br>
                    <strong>sans recharger la page</strong>"
                </p>
            </div>
        </div>

        <!-- Slide 3 -->
        <div class="slide">
            <h1>‚ö° La programmation r√©active</h1>
            
            <div class="info-box">
                <h3>üìñ D√©finition</h3>
                <p>La <strong>programmation r√©active</strong> est un paradigme de d√©veloppement dans lequel un programme <strong>r√©agit automatiquement</strong> aux changements de donn√©es ou d'√©v√©nements au lieu de les interroger activement.</p>
            </div>

            <div class="success-box">
                <h3>‚úÖ En d'autres termes</h3>
                <p>Le code ne "demande" plus la donn√©e : il <strong>s'abonne √† un flux de valeurs</strong> et se met √† jour d√®s qu'une nouvelle valeur est √©mise.</p>
            </div>

            <div class="highlight">
                <h3>üí° Exemple du quotidien</h3>
                <p><strong>Notifications sur nos t√©l√©phones</strong></p>
                <ul>
                    <li>‚ùå <strong>Approche classique</strong> : Ouvrir l'app toutes les 5 minutes pour voir s'il y a du nouveau</li>
                    <li>‚úÖ <strong>Approche r√©active</strong> : C'est le syst√®me qui nous pr√©vient d√®s qu'une nouvelle donn√©e est disponible</li>
                </ul>
            </div>
        </div>

        <!-- Slide 4 -->
        <div class="slide">
            <h1>üèóÔ∏è Une application r√©active Angular</h1>
            
            <div class="info-box">
                <h3>üé≠ Mod√®le bas√© sur trois r√¥les</h3>
                <ol style="font-size: 1.2em; line-height: 2;">
                    <li><strong>Le service</strong> : il fournit les donn√©es sous forme de flux (ex: des t√¢ches)</li>
                    <li><strong>Le composant</strong> : il s'abonne √† ces donn√©es, pour √™tre notifi√© √† chaque changement</li>
                    <li><strong>Le template (vue)</strong> : il affiche automatiquement la derni√®re valeur re√ßue gr√¢ce au <code>| async</code></li>
                </ol>
            </div>

            <div class="success-box">
                <h3>‚úÖ Approche d√©clarative</h3>
                <p>On ne dit pas <strong>"fais ceci quand tu re√ßois les donn√©es"</strong></p>
                <p>On dit <strong>"affiche cette donn√©e, et Angular s'occupera de la mettre √† jour quand elle changera"</strong></p>
            </div>

            <div class="flow-diagram">
                <div class="flow-step">Service</div>
                <span style="font-size: 2em;">‚Üí</span>
                <div class="flow-step">Composant</div>
                <span style="font-size: 2em;">‚Üí</span>
                <div class="flow-step">Template</div>
            </div>
        </div>

       <!-- Slide 5 -->
        <div class="slide">
            <h1>üõ†Ô∏è Cr√©ons un service</h1>
            
            <div class="info-box">
                <h3>üì¶ Commande Angular CLI</h3>
                <pre><code>ng generate service core/services/task
# ou
ng g s core/services/task</code></pre>
            </div>

            <div class="success-box">
                <h3>‚úÖ Fichiers g√©n√©r√©s</h3>
                <pre><code>src/app/core/services/
‚îú‚îÄ‚îÄ task.service.ts        // Service
‚îî‚îÄ‚îÄ task.service.spec.ts   // Tests</code></pre>
            </div>

            <div class="highlight">
                <h3>üí° Organisation : core/services/</h3>
                <p>Le dossier <strong>core/services/</strong> contient les services <strong>globaux</strong>, partag√©s par toute l'application.</p>
            </div>

            <div class="info-box">
                <h3>üîë Qu'est-ce que "providedIn: 'root'" ?</h3>
                <pre><code>@Injectable({
  providedIn: 'root'  // ‚Üê C'est quoi "root" ?
})
export class TaskService { ... }</code></pre>
                
                <p style="margin-top: 15px;"><strong>"root"</strong> signifie que le service est fourni <strong>au niveau racine de l'application</strong>.</p>
                
                <h4 style="margin-top: 20px;">üìä Cons√©quences :</h4>
                <ul>
                    <li><strong>Une seule instance</strong> du service existe dans toute l'app (singleton)</li>
                    <li><strong>Accessible partout</strong> : tous les composants peuvent l'injecter</li>
                    <li><strong>Donn√©es partag√©es</strong> : si TaskService stocke une liste de t√¢ches, tous les composants voient la m√™me liste</li>
                    <li><strong>Pas besoin de le d√©clarer</strong> dans les imports des composants</li>
                </ul>

                <h4 style="margin-top: 20px;">üèóÔ∏è M√©taphore :</h4>
                <p><strong>"root"</strong> = la cave de la maison</p>
                <ul>
                    <li>Il n'y a qu'<strong>une seule cave</strong> pour toute la maison</li>
                    <li>Toutes les pi√®ces (composants) peuvent y acc√©der</li>
                    <li>Ce qui est stock√© dans la cave est <strong>partag√© par tous</strong></li>
                </ul>
            </div>

    
        </div>
        <!-- Slide 6 -->
        <div class="slide">
            <h1>üíâ Injectons et utilisons le service</h1>
            
            <div class="success-box">
                <h3>üìù Code du service (task.service.ts)</h3>
                <pre><code>import { Injectable } from '@angular/core';
import { of } from 'rxjs';
import { delay } from 'rxjs/operators';

@Injectable({
  providedIn: 'root'
})
export class TaskService {
  private tasks = [
    { id: 1, title: 'Apprendre Angular' },
    { id: 2, title: 'Cr√©er TaskBoard Pro' }
  ];

  getTasks() {
    return of(this.tasks).pipe(delay(2000));
  }
}</code></pre>
            </div>

            <div class="success-box">
                <h3>üìù Utilisation dans le composant (home.ts)</h3>
                <pre><code>import { inject } from '@angular/core';
import { TaskService } from '../core/services/task.service';
import { AsyncPipe } from '@angular/common';

export class Home {
  private taskService = inject(TaskService);
  tasks$ = this.taskService.getTasks();
}</code></pre>
            </div>

            <div class="success-box">
                <h3>üìù Affichage dans le template (home.html)</h3>
                <pre><code>@if (tasks$ | async; as tasks) {
  &lt;ul&gt;
    @for (task of tasks; track task.id) {
      &lt;li&gt;{{ task.title }}&lt;/li&gt;
    }
  &lt;/ul&gt;
} @else {
  &lt;p&gt;Chargement...&lt;/p&gt;
}</code></pre>
            </div>
        </div>

        <!-- Slide 7 -->
        <div class="slide">
            <h1>‚è±Ô∏è L'asynchrone en action</h1>
            
            <div class="highlight" style="padding: 40px;">
                <p style="font-size: 1.4em; line-height: 1.8; text-align: center;">
                    "Le service met une seconde avant de renvoyer les t√¢ches,<br>
                    mais pendant ce temps, <strong>l'application reste fluide</strong> :<br>
                    elle affiche un message <code>Chargement‚Ä¶</code>,<br>
                    elle reste interactive,<br>
                    et Angular continue d'√©couter le flux.<br><br>
                    <strong>C'est √ßa, l'asynchrone.</strong>"
                </p>
            </div>

            <div class="info-box">
                <h3>üîë Concept cl√© : Asynchrone</h3>
                <ul>
                    <li>Le code n'attend PAS que les donn√©es arrivent pour continuer</li>
                    <li>L'interface reste responsive (r√©active aux clics, scrolls...)</li>
                    <li>Quand les donn√©es arrivent, Angular met √† jour automatiquement la vue</li>
                </ul>
            </div>
        </div>

        <!-- Slide 8 -->
        <div class="slide">
            <h1>üîÑ L'application continue de vivre pendant l'attente</h1>
            
            <div class="info-box">
                <h3>üí° D√©monstration : Compteur pendant le chargement</h3>
                <p>Pour prouver que l'application reste active pendant le chargement asynchrone, ajoutons un compteur :</p>
            </div>

            <div class="success-box">
                <h3>üìù Code TypeScript (home.ts)</h3>
                <pre><code>count = 0;

ngOnInit() {
  setInterval(() => {
    this.count++;
  }, 500);
}</code></pre>
            </div>

            <div class="success-box">
                <h3>üìù Code Template (home.html)</h3>
                <pre><code>&lt;p&gt;Temps √©coul√© : {{ count / 2 }} secondes&lt;/p&gt;</code></pre>
            </div>

            <div class="highlight">
                <h3>‚úÖ R√©sultat</h3>
                <p>Le compteur continue de s'incr√©menter pendant que les t√¢ches se chargent. L'application est bien <strong>asynchrone</strong> !</p>
            </div>
        </div>

        <!-- Slide 9 -->
        <div class="slide">
            <h1>üõë Arr√™ter le compteur</h1>
            
            <div class="warning-box">
                <h3>‚ö†Ô∏è Probl√®me</h3>
                <p>Si on change de page, le <code>setInterval()</code> continue de tourner en arri√®re-plan ! Cela cr√©e une <strong>fuite m√©moire</strong>.</p>
            </div>

            <div class="success-box">
                <h3>‚úÖ Solution : Nettoyer dans ngOnDestroy()</h3>
                <pre><code>count = 0;
intervalId: any;

ngOnInit() {
  this.intervalId = setInterval(() => {
    this.count++;
    console.log(this.count);
  }, 500);
}

ngOnDestroy() {
  console.log('Home d√©truit, interval arr√™t√©');
  clearInterval(this.intervalId);
}</code></pre>
            </div>

            <div class="info-box">
                <h3>üîë Bonne pratique</h3>
                <p>Toujours <strong>nettoyer les timers et abonnements</strong> dans <code>ngOnDestroy()</code> pour √©viter les fuites m√©moire.</p>
            </div>
        </div>

        <!-- Slide 10 -->
        <div class="slide">
            <h1>üöÄ Programmation r√©active compl√®te</h1>
            
            <div class="info-box">
                <h3>üîç Jusqu'ici</h3>
                <p>Notre service √©mettait une seule fois les donn√©es, avec un d√©lai.</p>
                <p>C'est <strong>asynchrone</strong>, mais ce n'est pas encore <strong>r√©actif au sens complet</strong>.</p>
            </div>

            <div class="success-box">
                <h3>üéØ Maintenant</h3>
                <p>On va faire en sorte que les donn√©es puissent <strong>changer</strong>, et qu'Angular mette la vue √† jour <strong>automatiquement</strong>, sans qu'on relance quoi que ce soit.</p>
            </div>

            <div class="highlight">
                <h3>üí° Objectif</h3>
                <p style="font-size: 1.3em; text-align: center;">
                    Cr√©er un <strong>flux vivant</strong> de donn√©es<br>
                    qui √©volue dans le temps
                </p>
            </div>
        </div>

        <!-- Slide 11 -->
        <div class="slide">
            <h1>üìö Parlons d'RxJS</h1>
            
            <div class="info-box">
                <h3>üìñ Qu'est-ce que RxJS ?</h3>
                <p><strong>RxJS (Reactive Extensions for JavaScript)</strong> est une biblioth√®que utilis√©e par Angular pour g√©rer les flux de donn√©es et tout ce qui change dans le temps :</p>
                <ul>
                    <li>Les appels HTTP</li>
                    <li>Les formulaires</li>
                    <li>Le routing</li>
                    <li>Les interactions utilisateur</li>
                </ul>
            </div>

            <div class="success-box">
                <h3>üîë Observable : Structure cl√©</h3>
                <p>RxJS introduit une nouvelle structure appel√©e <strong>Observable</strong>, qui permet √† une application :</p>
                <ul>
                    <li>D'<strong>√©couter</strong> des √©v√©nements ou des donn√©es qui changent dans le temps</li>
                    <li>De <strong>r√©agir automatiquement</strong> quand une nouvelle valeur est √©mise</li>
                    <li>De <strong>cha√Æner des op√©rations</strong> sur ces donn√©es (filtrer, transformer, combiner...)</li>
                </ul>
            </div>

            <div class="highlight">
                <h3>üí° En r√©sum√©</h3>
                <p style="text-align: center; font-size: 1.3em;">
                    <strong>RxJS est le moteur de la r√©activit√© d'Angular</strong>
                </p>
            </div>
        </div>

        <!-- Slide 12 -->
        <div class="slide">
            <h1>üîß Comment Angular utilise RxJS</h1>
            
            <div class="success-box">
                <h3>üìù Exemple actuel</h3>
                <pre><code>getTasks() {
  return of(this.tasks).pipe(delay(2000));
}</code></pre>
            </div>

            <div class="info-box">
                <h3>üîç Explications</h3>
                <ul>
                    <li><code>of(this.tasks)</code> ‚Üí cr√©e un <strong>Observable</strong> contenant la liste des t√¢ches</li>
                    <li><code>.pipe(delay(2000))</code> ‚Üí simule un appel HTTP (d√©lai de 2 secondes)</li>
                    <li>Le composant peut √©couter ce flux ‚Üí <code>tasks$ = task.getTasks();</code></li>
                    <li>Le template affiche automatiquement ‚Üí <code>{{ tasks$ | async }}</code></li>
                </ul>
            </div>

            <div class="highlight">
                <h3>üí° Concept cl√©</h3>
                <p>Ici, RxJS nous permet de travailler avec des donn√©es qui <strong>arrivent dans le temps</strong>.</p>
            </div>
        </div>

        <!-- Slide 13 -->
        <div class="slide">
            <h1>üåä Un flux vivant</h1>
            
            <div class="warning-box">
                <h3>‚ùå Limitation actuelle</h3>
                <p>Jusqu'ici, notre service √©mettait les donn√©es <strong>une seule fois</strong> gr√¢ce √† <code>of(...).pipe(delay())</code>.</p>
                <p>C'√©tait asynchrone, mais le flux s'arr√™tait d√®s la premi√®re √©mission.</p>
            </div>

            <div class="success-box">
                <h3>‚úÖ Dans une vraie application</h3>
                <p>Les donn√©es √©voluent dans le temps :</p>
                <ul>
                    <li>Un utilisateur <strong>ajoute</strong> une t√¢che</li>
                    <li>Une <strong>notification</strong> arrive</li>
                    <li>Une donn√©e change <strong>c√¥t√© serveur</strong></li>
                </ul>
            </div>

            <div class="info-box">
                <h3>üéØ Solution : BehaviorSubject</h3>
                <p>Nous avons besoin d'un <strong>flux actif</strong>, qui continue √† √©mettre des valeurs √† chaque changement.</p>
                <p>C'est le r√¥le du <strong>BehaviorSubject</strong> dans RxJS : il garde en m√©moire la derni√®re valeur √©mise, et notifie tous les abonn√©s d√®s qu'une nouvelle valeur appara√Æt.</p>
            </div>
        </div>

   <!-- Slide 14 -->
        <div class="slide">
            <h1>üíé Exemple avec BehaviorSubject</h1>
            
            <div class="info-box">
                <h3>üìù D'abord, d√©finir l'interface TaskItem</h3>
                <p>Pour typer correctement nos t√¢ches, on cr√©e une interface TypeScript :</p>
                <pre><code>// task.service.ts
export interface TaskItem {
  id: number;
  title: string;
  completed: boolean;
}</code></pre>
                <p><strong>üí° Pourquoi une interface ?</strong></p>
                <ul>
                    <li>‚úÖ TypeScript v√©rifie que nos t√¢ches ont bien ces propri√©t√©s</li>
                    <li>‚úÖ Autocompl√©tion dans VS Code</li>
                    <li>‚úÖ Erreurs d√©tect√©es AVANT l'ex√©cution</li>
                </ul>
            </div>

            <div class="success-box">
                <h3>üìù Code du service mis √† jour avec typage</h3>
                <pre><code>import { Injectable } from '@angular/core';
import { BehaviorSubject } from 'rxjs';

// 1Ô∏è‚É£ D√©finir l'interface
export interface TaskItem {
  id: number;
  title: string;
  completed: boolean;
}

@Injectable({
  providedIn: 'root'
})
export class TaskService {
  // 2Ô∏è‚É£ Typer les t√¢ches initiales
  private tasks: TaskItem[] = [
    { id: 1, title: 'Apprendre Angular', completed: false },
    { id: 2, title: 'Cr√©er TaskBoard Pro', completed: false }
  ];

  // 3Ô∏è‚É£ Typer le BehaviorSubject
  private tasksSubject = new BehaviorSubject&lt;TaskItem[]&gt;(this.tasks);
  tasks$ = this.tasksSubject.asObservable();

  // 4Ô∏è‚É£ Typer les param√®tres et retours
  addTask(title: string): void {
    const newTask: TaskItem = { 
      id: Date.now(), 
      title,
      completed: false 
    };
    this.tasks.push(newTask);
    this.tasksSubject.next(this.tasks);
  }
}</code></pre>
            </div>

          
        </div>

        <!-- Slide 15 -->
        <div class="slide">
            <h1>üìù Modification de home.html</h1>
            
            <div class="success-box">
                <h3>üìù Template mis √† jour</h3>
                <pre><code>&lt;h2&gt;Mes t√¢ches&lt;/h2&gt;

&lt;!-- Formulaire d'ajout --&gt;
&lt;input #taskInput placeholder="Nouvelle t√¢che"&gt;
&lt;button (click)="addTask(taskInput.value); taskInput.value = ''"&gt;
  Ajouter
&lt;/button&gt;

&lt;!-- Liste des t√¢ches --&gt;
@if (tasks$ | async; as tasks) {
  &lt;ul&gt;
    @for (task of tasks; track task.id) {
      &lt;li&gt;{{ task.title }}&lt;/li&gt;
    }
  &lt;/ul&gt;
} @else {
  &lt;p&gt;Chargement...&lt;/p&gt;
}
</code></pre>
            </div>

            <div class="highlight">
                <h3>üí° Ce qui se passe</h3>
                <ol>
                    <li>L'utilisateur tape un titre et clique sur "Ajouter"</li>
                    <li>La m√©thode <code>addTask()</code> du composant est appel√©e</li>
                    <li>Le service ajoute la t√¢che et √©met <code>next()</code></li>
                    <li>Le template re√ßoit la nouvelle liste via <code>| async</code></li>
                    <li>Angular rafra√Æchit automatiquement la vue !</li>
                </ol>
            </div>
        </div>

        <!-- Slide 16 -->
        <div class="slide">
            <h1>üéØ Modification de home.ts</h1>
            
            <div class="success-box">
                <h3>üìù Composant mis √† jour</h3>
                <pre><code>import { Component, inject } from '@angular/core';
import { TaskService } from '../core/services/task.service';
import { AsyncPipe } from '@angular/common';

@Component({
  selector: 'app-home',
  standalone: true,
  imports: [AsyncPipe],
  templateUrl: './home.html'
})
export class Home {
  private taskService = inject(TaskService);
  tasks$ = this.taskService.tasks$;

  addTask(title: string) {
    if (title.trim()) {
      this.taskService.addTask(title);
    }
  }
}</code></pre>
            </div>

            <div class="highlight">
                <h3>üí° Analogie du carnet partag√©</h3>
                <p style="font-size: 1.2em; line-height: 1.8;">
                    Le <strong>BehaviorSubject</strong>, c'est comme un <strong>carnet partag√©</strong> :<br>
                    le service note toujours la derni√®re version de la liste,<br>
                    et n'importe quel composant qui vient consulter le carnet, m√™me plus tard,<br>
                    voit tout de suite la <strong>derni√®re version</strong>, pas une vieille copie.
                </p>
            </div>
        </div>

        <!-- Slide 17 -->
        <div class="slide">
            <h1>‚ôªÔ∏è Rappel : Cycle de vie du flux</h1>
            
            <div class="flow-diagram">
                <h3>Flux de donn√©es r√©actif</h3>
                <div style="margin-top: 30px;">
                    <div class="flow-step">Service</div>
                    <div style="margin: 20px 0; font-size: 1.2em;">√©met une nouvelle valeur (<code>next()</code>)</div>
                    <span style="font-size: 2em;">‚Üì</span>
                    <div class="flow-step">Composant</div>
                    <div style="margin: 20px 0; font-size: 1.2em;">re√ßoit automatiquement la mise √† jour</div>
                    <span style="font-size: 2em;">‚Üì</span>
                    <div class="flow-step">Template</div>
                    <div style="margin: 20px 0; font-size: 1.2em;">se r√©-affiche via <code>| async</code></div>
                </div>
            </div>

            <div class="info-box">
                <h3>üîë Concept cl√©</h3>
                <p>Le composant ne g√®re plus les donn√©es lui-m√™me : il <strong>√©coute un flux</strong>.</p>
                <p>√Ä chaque mise √† jour dans le service, Angular d√©tecte et rafra√Æchit la vue.</p>
            </div>
        </div>

        <!-- Slide 18 -->
        <div class="slide">
            <h1>üìö Synth√®se</h1>
            
            <div class="success-box">
                <h3>‚úÖ Ce que nous avons appris</h3>
                <ul style="font-size: 1.2em; line-height: 2;">
                    <li>Dans Angular, le composant ne <strong>pilote</strong> plus les donn√©es. Il les <strong>observe</strong>.</li>
                    <li>C'est <strong>RxJS</strong>, via <code>BehaviorSubject</code>, qui garantit la mise √† jour automatique du rendu.</li>
                    <li>Le <code>| async</code> g√®re automatiquement l'abonnement et le d√©sabonnement.</li>
                </ul>
            </div>

            <div class="highlight">
                <h3>üíº En entreprise</h3>
                <p style="font-size: 1.3em;">
                    "Cette approche permet de mieux <strong>s√©parer les responsabilit√©s</strong> :<br>
                    les services g√®rent les donn√©es,<br>
                    les composants g√®rent la pr√©sentation."
                </p>
            </div>

            <div class="info-box">
                <h3>üéØ Avantages</h3>
                <ul>
                    <li>Code plus maintenable</li>
                    <li>Moins de bugs (pas de gestion manuelle des abonnements)</li>
                    <li>Performance optimis√©e (Angular sait quand rafra√Æchir)</li>
                </ul>
            </div>
        </div>

        <!-- Slide 19 -->
        <div class="slide">
            <h1>üõ†Ô∏è TP fil rouge</h1>
            
            <div class="info-box">
                <h3>1Ô∏è‚É£ Cr√©e une nouvelle branche Git</h3>
                <pre><code>git checkout -b sequence-2-rxjs
git add .
git commit -m "Mise en place de la r√©activit√© avec RxJS"</code></pre>
            </div>

            <div class="success-box">
                <h3>2Ô∏è‚É£ Ajoute les notions cl√©s dans README.md</h3>
                <p>√âcris une courte section contenant :</p>
                <ul>
                    <li>Les concepts que tu as compris</li>
                    <li>Ce que fait <strong>BehaviorSubject</strong></li>
                    <li>Ce que fait <strong>| async</strong></li>
                    <li>Comment fonctionne le flux <strong>service ‚Üí composant ‚Üí template</strong></li>
                </ul>
            </div>

            <div class="warning-box">
                <h3>üì¶ Livrable</h3>
                <p>Pousse ta branche sur GitHub et partage le lien dans le formulaire de rendu.</p>
            </div>
        </div>

        <!-- Slide 20 -->
        <div class="slide">
            <h1>üìù Exemple README.md</h1>
            
            <div class="success-box">
                <h3>üìÑ Exemple de documentation</h3>
                <pre><code>## S√©quence 2 ‚Äì Logique r√©active du flux de donn√©es

### 1. Structure du flux
- Le service `TaskService` utilise un **BehaviorSubject** 
  pour stocker et diffuser la liste des t√¢ches.
- Le composant `Home` s'abonne √† ce flux via `tasks$` 
  et le **pipe async**.

### 2. Mise √† jour des donn√©es
- La m√©thode `addTask()` ajoute une t√¢che puis appelle 
  `next()` pour √©mettre la nouvelle liste.
- La m√©thode `removeTask()` supprime une t√¢che puis √©met 
  √† nouveau la liste mise √† jour.
- La vue est automatiquement r√©actualis√©e sans rechargement.

### 3. Points cl√©s retenus
- Pas besoin d'appeler `getTasks()` √† chaque fois : 
  la donn√©e est **vivante**.
- `| async` g√®re l'abonnement et le d√©sabonnement 
  automatiquement.
- Le flux reste coh√©rent entre le service et la vue.</code></pre>
            </div>
        </div>

        <div class="controls">
            <button id="prev-btn">‚Üê Pr√©c√©dent</button>
            <button id="next-btn">Suivant ‚Üí</button>
        </div>
    </div>

    <script>
        let currentSlide = 0;
        const slides = document.querySelectorAll('.slide');
        const totalSlides = slides.length;
        const prevBtn = document.getElementById('prev-btn');
        const nextBtn = document.getElementById('next-btn');
        const currentSlideSpan = document.getElementById('current-slide');
        const totalSlidesSpan = document.getElementById('total-slides');

        totalSlidesSpan.textContent = totalSlides;

        function showSlide(n) {
            slides.forEach(slide => slide.classList.remove('active'));
            slides[n].classList.add('active');
            currentSlideSpan.textContent = n + 1;
            
            prevBtn.disabled = n === 0;
            nextBtn.disabled = n === totalSlides - 1;
            
            slides[n].scrollTop = 0;
        }

        function nextSlide() {
            if (currentSlide < totalSlides - 1) {
                currentSlide++;
                showSlide(currentSlide);
            }
        }

        function prevSlide() {
            if (currentSlide > 0) {
                currentSlide--;
                showSlide(currentSlide);
            }
        }

        nextBtn.addEventListener('click', nextSlide);
        prevBtn.addEventListener('click', prevSlide);

        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowRight') nextSlide();
            if (e.key === 'ArrowLeft') prevSlide();
        });

        showSlide(0);
    </script>
</body>
</html>